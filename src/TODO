
//RÃ©Ã©crire le grouper !!!!!

//!Chaque plugin est DEUX fois dans la liste !



//ï»¿Une dÃ©pendance entre PluginBase et PluginManager, Ã  discuter
//RÃ©cupÃ©ration du nom du jar : ... le dossier plugins n'est pas fixe....
//Les dÃ©pendances cycliques ! Pas encore vÃ©rifiÃ©es.  => osef : impossible à faire involontairement
//Lazy et co : Ã  revoir, pas grand sens pour le runnable par exemple. En fait si.

Validate : ne pas tout quitter, gÃ©rer les exceptions.

CHARGER des bins (class) directement
Exporter dans un dossier le .xml


//A priori réglé dans la foulée.
///!\ Le nom du jar est utilisÃ© ! Utiliser le nom du plugin !
//TOUJOURS utiliser le NOM du PLUGIN (et pas celui du jar...)

//Commencer Ã  implÃ©menter le xml.

JAVADOC

Dependancies = dependencies.

Load : vérifier si plusieurs fois le même nom.

Demander un plugin par type.

Le pb du dossier linux/windows (plugins)

//Ajout d'un attribut : launch to start.

Ajouter un proxy lors d'une rï¿½fï¿½rence vers un objet d'un autre plugin.

Dï¿½pendances : mettre tout le groupe dans le mï¿½me classLoader => plus de findClass. (ou alors pour la gestion du lazy : arbre : classLoaderDeGroupe{ClassLoaders de plugins}

On n'implï¿½mente plus IPluginRunnable : ou extend une classe qui l'implï¿½mente, et qui contient les mï¿½thodes donneMoiLesPluginsQuiImplï¿½mentent/ExtendTelTruc.
Contentprovider implï¿½mente donneMoiUnObject => lazy lï¿½ dessus. De base le getObject(nom_du_plugin) renvoie this. (rï¿½cupï¿½re une instance de la classe principale)


Classes statiques ?

Controler l'extension du fichier

GetObject : args ?

//faire getPluginList => pb, comment connaitre le plugin manager ?